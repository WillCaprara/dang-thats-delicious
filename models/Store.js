//mongoose is the package used to interface with mongodb.
//mongo db can be used with any language like python, ruby, php etc.
//one of the poppular ways to interface with mongdb in node is mongoose.
const mongoose = require('mongoose');
//There are a couple of ways that we can wiat for our data to come back from the db because it thappens asynchronously.
//You can use the built in callbacks, you can use an external promise library like bluebird or, like in this model, use the built in ES6 promise (async - await)
mongoose.Promise = global.Promise;
//This library allows us to make url friendly to access a resource
const slug = require('slugs');

const storeSchema = new mongoose.Schema({
    name: {
        type: String,
        //Do all your data normalization as close to the model as possible
        trim: true,
        required: 'Please enter a store name!'
    },
    slug: String, //autogenerated
    description: {
        type: String,
        trim: true
    },
    tags: [String],
    created: {
        type: Date,
        default: Date.now
    },
    location: {
        type: {
            type: String,
            default: 'Point'
        },
        coordinates: [{
            type: Number,
            required: 'You must supply coordinates!'
        }],
        address: {
            type: String,
            required: 'You must supply an address!'
        }
    },
    photo: String,
    author: {
        type: mongoose.Schema.ObjectId, //Object Id of the user in mongodb, because its going to be a relationship between the actual store and the user.
        ref: 'User', //This is where we tell mongodb that our author will be referencing our User
        required: 'You must supply an author'
    }
}, {
    //Whenever you convert your data into an actual model (object) or json, it will by default, not put virtuals in that object or  in that json.
    //If we want to make it so that virtuals are put on the object or json, we pass the following options to our schema:
    toJSON: { virtuals: true },
    toObject: { virtuals: true }
});

//Define indexes
storeSchema.index({
    //In this case we are indexing as 'text', because that will make it possible to search within that very efficiently and do some stuff like case sensitivity and whatnot.
    name: 'text',
    description: 'text'
});

//Geospatial indexing is goinfg to store the metadata about a location as geospatial data and then we will be able to quickly search for stores that are near a lat and long that we pass it.
storeSchema.index({
    location: '2dsphere'
});

//pre save hook - before somebody saves a store, we are going to autogenerate a slug field
storeSchema.pre('save', async function(next) {
    //Only run it when name changes
    if(!this.isModified('name')){
        next();
        return;
    }
    this.slug = slug(this.name);

    //Before we save the actual store, we are going to check if there are any other stores with that same slug.
    //Find other stores that have a slug of storename, storename-2, storename-2
    //Make a regex that is going to search for stores that have a slug of storename, storename-1, storename-2 etc...
    //^(${this.slug}) -> So far what this means is that we are searching for urls that start with this.slug
    //Dollar sign ($) means 'it ends with'.
    //What this means is we are looking for something with a slug that might end in -1,-2,-3,-4,-5 etc.
    const slugRegEx = new RegExp(`^(${this.slug})((-[0-9]*$)?)$`, 'i');//The second parameter 'i', means it's case insensitive, so if we have uppercase or lowercase, I don't want to have slugs overwriting each other by that.
    //Pass regex into a query.
    //We use this.constructor, because since we are in the pre save hook, we don't have the Store model available yet. this.constructor will be equal to Store (model) by the time it actually runs.
    const storesWithSlug = await this.constructor.find({ slug: slugRegEx });
    if(storesWithSlug.length) {
        this.slug = `${this.slug}-${storesWithSlug.length + 1}`;
    }

    next();
});

//To add a method onto a schema you put it into "statics".
//We use proper a function, not an () => because we need to use "this". In an arrow function you can't use "this". All of the static methods are bound to the model, meaning that we can use this.find, this.findOne etc...
//aggregate is just a method like find, findOne etc. aggregate will take an array of possible operators of what we are looking for.
//mongodb aggregation operators documentation: https://docs.mongodb.com/manual/reference/operator/aggregation/
//In this case we are going to use $unwind first, because we are going to group all of our items by the number of tags they have but before we can group them you need to unwind your stores so that for every single tag that exists for a store there is going to be that many stores.
storeSchema.statics.getTagsList = function () {
    return this.aggregate([
        //By unwinding them, for example for Brew Bar it has 2 tags Family Friendly and Licensed, so,we get an instance of a store for Family Friendly and an instance of a store for Licensed.
        { $unwind: '$tags' }, //By putting a $ in front of tags, you are saying that its a field in your document which I wish to unwind.
        //Here we are going to group everything based on the tag field, then we are going to create a new field in each of those groups called count. Each time taht we group one of this items, the count is going to sum itself by one.
        { $group: { _id: '$tags', count: { $sum: 1 } } }, 
        //Sort
        { $sort: { count: -1 } }, //1 -> acending; -1 -> descending
    ]);
}

storeSchema.statics.getTopStores = function() {
    return this.aggregate([
        //Lookup Stores and populate their reviews.
        //We can't actually use our virtual -> reviews field because that is a mongooose specific thing. And this.aggregate is not mongoose specific, it just passes out to MongoDB.
        //Sort of a downside of some of these "convenience" methods in mogoose, is that you can use them every possible place because if you for example do it at .aggregate, it doesn't know about them because it's like a lower level MongoDB function that doesn't know about "higher level" mongoose things.
        //$lookup will populate a field, sort of like a virtual.
        //We are doing something similar to the .virtual, the only difference is our from is "reviews" because MongoDB will take your model name (in this case "Review") and it will lower case it and put an "s" at the end.
        { $lookup: {
            from: 'reviews',  localField: '_id', 
            foreignField: 'store', as: 'reviews' 
            } 
        },
        //Filter for only items that have 2 or more reviews.
        //Match documents where reviews.1 (is how you access things that are index based in MongoDB; reviews.0 would be the first element, reviews.1 the second etc).
        //So, here we are saying: where the second item in reviews array exists (making sure it has at least 2 reviews).
        { $match: { 'reviews.1': { $exists: true } } },
        //Add average reviews field.
        //What we are saying here is: Create a new field called averageRating, and set the value of that to be the value of each of the reviews raitng field.
        //Version 3.4 will have $addField operator that will take your current document and add a new field to it. With MongoDB 3.4- and our free tier MongoDB 3.4+ we have to add all the fields back in. So we just sort of created our new document and thats sort what aggregations are for.
        { $project: { 
                photo: '$$ROOT.photo',
                name: '$$ROOT.name',
                reviews: '$$ROOT.reviews',
                slug: '$$ROOT.slug',
                averageRating: { $avg: '$reviews.rating' } 
            } 
        },
        //Sort ir by our new field, highest reviews first.
        { $sort: { 
            averageRating: -1 
            } 
        },
        //Limit to at most 10.
        { $limit: 10 }
    ]);
};

//Find reviews where the stores _id property === reviews store property.
//This is sort of like a join in sql, but its virtual so we are not actually saving any sort of relationship between the two.
storeSchema.virtual('reviews', {
    //We are going to tell it to go off to another model, in this case our review model, and actually do a quick query for us.
    ref: 'Review', //what model to link?
    //Which field on our store needs to match up to which field on our foreign model.
    localField: '_id', //which field on the store?
    foreignField: 'store' //which field on the review?

});

//When the store is actually queried, we will autopopulate the author.
function autopopulate(next) {
    this.populate('reviews');
    next();
};

//Add hooks for anytime somebody finds or findsOne adn it's going to populate the author field for each of those.
storeSchema.pre('find', autopopulate);
storeSchema.pre('findOne', autopopulate);

//If the main thing that you are exporting from a file is going to be importable then you put it in module.exports
module.exports = mongoose.model('Store', storeSchema);

